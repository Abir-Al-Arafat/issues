# Technical Problem Solving: Resolving Critical Git Deadlocks in Production

## 1. The Challenge (Situation & Task)

While maintaining the **Hopper Roadside Dashboard**, I encountered a critical "Git Deadlock" during a deployment cycle. A `git pull` failed with a fatal error due to unresolved merge conflicts in key configuration files (`package-lock.json` and `vite.config.js`).

The goal was to synchronize the production server with the latest remote changes without losing local environment-specific configurations or corrupting the dependency tree.

## 2. The Action (Process)

I followed a systematic 4-step approach to resolve the divergence:

### Phase 1: Conflict Identification

I used `git status` to isolate the "Unmerged paths." I identified that both the local environment and the remote repository had modified the build tool configurations and the dependency lockfile.

### Phase 2: Strategic Resolution

Instead of a blind merge, I applied specific strategies for different file types:

- **Configuration (`vite.config.js`):** I manually reviewed the deltas to ensure the server-side environment variables were preserved.
- **Dependencies (`package-lock.json`):** I prioritized the upstream (remote) version to maintain consistency with the development team’s environment using `git checkout --theirs`.

### Phase 3: Reconciliation Strategy

Git triggered a "divergent branches" warning. I configured the reconciliation strategy to `pull.rebase false`. This allowed for a clean merge commit, providing a clear audit trail in the git history—essential for team-based dashboard development.

### Phase 4: Verification & Deployment

After finalizing the merge, I executed a clean build cycle:

1. `npm install` to sync the node_modules with the newly merged lockfile.
2. `npm run build` to verify that the conflict resolution didn't break the Vite bundling process.

## 3. The Result (Impact)

- **Zero Downtime:** The dashboard remained stable throughout the resolution.
- **History Integrity:** Maintained a clean, readable Git log that documented exactly how the conflicts were settled.
- **Process Optimization:** Set a global git configuration for the server to streamline future updates, reducing deployment friction.

## 4. Key Takeaways

This experience reinforced the importance of:

- Understanding the difference between `merge` and `rebase` in production environments.
- Knowing how to handle autogenerated files like `package-lock.json` without manual corruption.
- Staying calm under terminal-level "fatal" errors to ensure data integrity.
